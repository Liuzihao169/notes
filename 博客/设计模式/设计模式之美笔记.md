设计模式

“设计模式的目的就是为了解开耦”

### 一、创建者模式

####  1.原型模式

#### 2.工厂模式

简单工厂（也就是使用习惯）、工厂方法（定义一个创建接口、由子类决定创建）、抽象工厂(定义了创建一系列相关接口的类，无需指定具体的类，主要是产品族)

#### 3.建造者模式

建造者模式用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象；如果一个类有多个属性，导致构造函数过长；

#### 4.原型模式

如果创建一个对象的成本较大、利用已有的对象进行复制来创建新的对象



### 二、结构模式

#### 1. 代理模式

代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，

而非加强功能，这是它跟装饰器模式最大的不同。比如：监控、统计、鉴权、限流、事

务、幂等、日志。

#### 2. 桥接模式

理解起来就是将抽象和实现进行节藕，能够独立开发。**组合优于继承**；这里指出的抽象并不是指 定义出来的接口或抽象类，这里指的是一套类库，而实现也是一套独立的类库，然后组合起来形成 **接口 + 实现**

#### 3. 装饰器模式

装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承，给原始类添加增强功

能。这也是判断是否该用装饰器模式的一个重要的依据

#### 4. 适配器模式

适配模式主要就是来适配，它将不同的接口转换为可以适配的接口，主要就是解决前期设计不足的一种补救措施。

- 封装有缺陷的接口设计、统一多个类的接口设计、替换依赖的外部系统、兼容老版本接口、适配不同格式的数据

#### 5. 门面模式

门面模式原理、实现都非常简单，应用场景比较明确。它通过封装细粒度的接口，提供组合 各个细粒度接口的高层次接口，来提高接口的易用性，或者解决性能、分布式事务等问题。

#### 6. 组合模式

对于数据结构算法是一种抽象， 部分-整体可以用一种 形式表现；可以进行递归的遍历

#### 7. 享元模式

所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提

是享元对象是不可变对象。当一个系统中存在大量重复对象的时候，我们就可以利用享元模式，将对象设计

成享元

把可以复用的对象“缓存”起来设置为共享，目的是为了节省内存，通过List或者Map来存储已经创建好的对象

**String、与 Integer中使用了享元模式**

```java
static final int low = -128;
static final int high; 
// -128 ~ 127 会缓存在cache当中
static final Integer cache[];
```

当使用构造方法创建的Integer对象并不会使用cache缓存

```java
//String类在运行时使用JVM提供的一块称之为“字符串常量池”的区
//域中来存储首次使用到的字符串常量，当后面再次使用到该常量时，直接去字符串常量
String a = "abc";
String b = "abc";
a和b 会同时指向同一个常量对象
```

### 三、行为模式

#### 1.解释器模式

解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。

#### 2.观察者模式 

 **EventBus**框架，可以实现观察者模式的骨架代码，它不仅仅支持异步非阻塞

模式，同时也支持同步阻塞模式。

行为-与触发事件的节藕；

观察者注册之后，被观察者主动推送数据到观察者，也是发布事件；

#### 3.模版模式

定义算法骨架；回调函数A调用B方法  最后B执行A中注册到B中的方法

#### 4.策略模式

工厂模式  + 策略模式 解决if-else 问题；最大的作用还是解耦合、将定义好的算法策略进行解耦

#### 5.责任链模式

业务链的传递，业务链条的传递

#### 6.状态链模式

事件状态机的转变，在对象内部改变状态，就仿佛改变了对象的行为，其实就是对策略模式的一个扩展使用

#### 7. 访问者模式

允许一个或者多个操作应用到一组对象上，接耦操作和对象本身。

接口调用方法，把实现传进去； 然后实现再调用this,解决当前对象问题

```java
public void accept(Extractor extractor) { 
  extractor.extract2txt(this); 
}
resourceFile.accept(extractor);
// 然后就可以实现   extractor.extract2txt(实现的重载); 

```

将操作封装成了对象、与实际要操作的对象进行了分离；

#### 8.备忘录模式

就是在不违背封装的前提下，捕捉一个对象的内部状态，并且在对象之外保存这个状态。

#### 9.命令模式

命令模式将请求封装成一个对象，这样可以使用不同的请求 参数化其对象；

#### 10.中介者模式

将错纵复杂的调用关系，处理成一个星型关系，集中管理，类似于zookeeper一样的一个注册中心，类属于广义的中介者。

### 四、设计模式的使用案例

#### 1. **Calendar-工厂模式 和 创建者模式**

#### 2. Collections 

装饰者模式:

```java
// 不可修改的类
Collection<T> unmodifiableCollection
```















